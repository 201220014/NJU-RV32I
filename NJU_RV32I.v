
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module NJU_RV32I(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);


	//////////// Reset //////////
	wire rstclk, rstcpu, rstps2, rstvga;
	
	assign rstclk = SW[0];
	assign rstcpu = ~KEY[1];
	assign rstps2 = KEY[0];
	assign rstvga = SW[2];
	assign rstfifo = SW[3];


	//////////// 25MHz Clock //////////
	wire clk;
	clkgen #(25000000) myclk(
		.clkin(CLOCK_50),
		.rst(rstclk),
		.clken(1'b1),
		.clkout(clk)
	);
	wire cpuclk;
	assign cpuclk = clk;


	//////////// CPU //////////
	
	// outputs:
	wire [31:0] imemaddr, vaddr;
	wire [31:0] cpudataout, dbgdata;
	wire imemclk, cpurdclk, cpuwrclk, we;
	wire [2:0] dmemop;
	// inputs:
	wire [31:0] imemdataout, cpudatain;

	rv32is myrv32i(
		.clock(cpuclk),
		.reset(rstcpu),
		.imemdataout(imemdataout),
		.dmemdataout(cpudatain),
		.imemaddr(imemaddr),
		.imemclk(imemclk),
		.dmemaddr(vaddr),
		.dmemdatain(cpudataout),
		.dmemrdclk(cpurdclk),
		.dmemwrclk(cpuwrclk),
		.dmemop(dmemop),
		.dmemwe(cpuwe),
		.dbgdata(dbgdata)
	);
	bcd7seg myseg0(dbgdata[3:0], HEX0);
	bcd7seg myseg1(dbgdata[7:4], HEX1);
	bcd7seg myseg2(dbgdata[11:8], HEX2);
	bcd7seg myseg3(dbgdata[15:12], HEX3);


	//////////// Main Memory //////////

	wire dmemwren, smemwren;
	assign dmemwren = cpuwe && vaddr[31:20] == 12'h001;
	assign smemwren = cpuwe && vaddr[31:20] == 12'h002;
	
	assign keyrden = vaddr[31:20] == 12'h003;
	
	wire [31:0] dmemdataout;
	wire [7:0] keyascii;
	assign cpudatain = vaddr[31:20] == 12'h003 ? {24'h0, keyascii} : dmemdataout;
	
	// Instruction Memory -- Starts With 0x000
	irom myirom(
		.address(imemaddr[14:2]),
		.clock(imemclk),
		.q(imemdataout)
	);

	// Data Memory -- Starts With 0x001
	dmem mydmem(
		.addr(vaddr),
		.dataout(dmemdataout),
		.datain(cpudataout),
		.rdclk(cpurdclk),
		.wrclk(cpuwrclk),
		.memop(dmemop),
		.we(dmemwren)
	);
	

	// Screen Memory -- Starts With 0x002
	wire [7:0] smemoutdata;
	wire [11:0] smemrdaddr;
	wire smemrdclk;
	screen_ram mysmem(
		.data(cpudataout[7:0]),
		.rdaddress(smemrdaddr),
		.rdclock(smemrdclk),
		.wraddress(vaddr[11:0]),
		.wrclock(cpuwrclk),
		.wren(smemwren),
		.q(smemoutdata)
	);
	

	// Keyboard FIFO -- Starts With 0x003
	wire [7:0] ascii_code;
	fifo myfifo(
		.ascii_code(ascii_code),
    	.wrclk(clk),
    	.rdclk(cpurdclk),
    	.rden(keyrden),
    	.rst(rstfifo),
    	.dataout(keyascii)
	);

	//////////// External Device //////////

	// PS2 Keyboard
	wire[7:0] scancode, raw_ascii;
	wire shift, ctrl, capslock;
	keyboard mykeybd(
		.clk(clk),
		.clrn(rstps2),
		.ps2_clk(PS2_CLK),
		.ps2_data(PS2_DAT),
		.cur_key(scancode),
		.shift(shift),
		.ctrl(ctrl),
		.capslock(capslock)
	);
	ascii_rom myascii_rom(
		.address(scancode),
		.clock(clk),
		.q(raw_ascii)
	);
	check_case mycheck(
		.raw_ascii(raw_ascii),
		.capslock(capslock),
		.shift(shift),
		.asciicode(ascii_code)
	);
	
	// debug
	assign LEDR[2:0] = {ctrl, shift, capslock};
	bcd7seg myseg4(ascii_code[3:0], HEX4);
	bcd7seg myseg5(ascii_code[7:4], HEX5);

	// VGA Screen
	wire [23:0] vga_data;
	wire [9:0] h_addr, v_addr;
	assign VGA_CLK = clk;
	assign VGA_SYNC_N = 0;
	vga_ctrl myvga(
		.pclk(clk),
		.reset(rstvga),
		.vga_data(vga_data),
		.h_addr(h_addr),
		.v_addr(v_addr),
		.hsync(VGA_HS),
		.vsync(VGA_VS),
		.valid(VGA_BLANK_N),
		.vga_r(VGA_R),
		.vga_g(VGA_G),
		.vga_b(VGA_B)
	);
	loadscreen myloader(
		.pclk(clk),
		.rst(rstvga),
		.ascii_code(smemoutdata),
		.h_addr(h_addr),
		.v_addr(v_addr),
		.rdclk(smemrdclk),
		.rdaddr(smemrdaddr),
		.vga_data(vga_data)
	);

endmodule
