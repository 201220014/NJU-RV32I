
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module NJU_RV32I(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);


	//////////// Reset //////////
	wire rstclk, rstcpu, rstps2, rstvga, rsttime;
	
	assign rstclk = SW[0];
	assign rstvga = SW[1];
	assign rstfifo = SW[2];
	
	assign rstcpu = ~KEY[0];
	assign rstps2 = KEY[1];
	assign rsttime = KEY[2];


	//////////// 25MHz Clock //////////
	wire clk;
	clkgen #(25000000) myclk(
		.clkin(CLOCK_50),
		.rst(rstclk),
		.clken(1'b1),
		.clkout(clk)
	);
	wire cpuclk;
	assign cpuclk = clk;


	//////////// CPU //////////
	
	// outputs:
	wire [31:0] imemaddr, vaddr;
	wire [31:0] cpudataout, dbgdata;
	wire imemclk, cpurdclk, cpuwrclk, we;
	wire [2:0] dmemop;
	// inputs:
	wire [31:0] imemdataout, cpudatain;

	rv32is myrv32i(
		.clock(cpuclk),
		.reset(rstcpu),
		.imemdataout(imemdataout),
		.dmemdataout(cpudatain),
		.imemaddr(imemaddr),
		.imemclk(imemclk),
		.dmemaddr(vaddr),
		.dmemdatain(cpudataout),
		.dmemrdclk(cpurdclk),
		.dmemwrclk(cpuwrclk),
		.dmemop(dmemop),
		.dmemwe(cpuwe),
		.dbgdata(dbgdata)
	);

	//////////// Main Memory //////////

	wire dmemwren, smemwren;
	assign dmemwren = cpuwe && vaddr[31:20] == 12'h001;
	assign smemwren = cpuwe && vaddr[31:20] == 12'h002;
	assign bcdwren = cpuwe && vaddr[31:20] == 12'h004;
	assign ledwren = cpuwe && vaddr[31:20] == 12'h005;
	
	assign keyrden = vaddr[31:20] == 12'h003;
	
	wire [31:0] dmemdataout;
	wire [7:0] keyascii;
	wire [23:0] timereg;
	assign cpudatain = vaddr[31:20] == 12'h003 ? {24'h0, keyascii} : (vaddr[31:20] == 12'h006 ? {8'h0, timereg} : dmemdataout);
	
	// Instruction Memory -- Starts With 0x000
	irom myirom(
		.address(imemaddr[14:2]),
		.clock(imemclk),
		.q(imemdataout)
	);

	// Data Memory -- Starts With 0x001
	dmem mydmem(
		.addr(vaddr),
		.dataout(dmemdataout),
		.datain(cpudataout),
		.rdclk(cpurdclk),
		.wrclk(cpuwrclk),
		.memop(dmemop),
		.we(dmemwren)
	);
	

	// Screen Memory -- Starts With 0x002
	wire [7:0] smemoutdata;
	wire [11:0] smemrdaddr;
	wire smemrdclk;
	screen_ram mysmem(
		.data(cpudataout[7:0]),
		.rdaddress(smemrdaddr),
		.rdclock(smemrdclk),
		.wraddress(vaddr[11:0]),
		.wrclock(cpuwrclk),
		.wren(smemwren),
		.q(smemoutdata)
	);
	

	// Keyboard FIFO -- Starts With 0x003
	wire [7:0] ascii_code;
	fifo myfifo(
		.ascii_code(ascii_code),
    	.wrclk(clk),
    	.rdclk(cpurdclk),
    	.rden(keyrden),
    	.rst(rstfifo),
    	.dataout(keyascii)
	);
	
	// BCD REG -- Starts With 0x004
	reg[23:0] bcdreg;
	always @(posedge cpuwrclk) begin
		if (bcdwren) begin
			bcdreg <= cpudataout[23:0];
		end
	end
	
	// LED REG -- Starts with 0x005
	reg[7:0] ledreg;
	always @(posedge cpuwrclk) begin
		if (ledwren) begin
			ledreg[vaddr[2:0]] <= cpudataout[0];
		end
	end
	
	// Time REG -- Starts with 0x006
	
	
	

	//////////// External Device //////////

	// PS2 Keyboard
	wire[7:0] scancode, raw_ascii;
	wire shift, ctrl, capslock;
	keyboard mykeybd(
		.clk(clk),
		.clrn(rstps2),
		.ps2_clk(PS2_CLK),
		.ps2_data(PS2_DAT),
		.cur_key(scancode),
		.shift(shift),
		.ctrl(ctrl),
		.capslock(capslock)
	);
	ascii_rom myascii_rom(
		.address(scancode),
		.clock(clk),
		.q(raw_ascii)
	);
	check_case mycheck(
		.raw_ascii(raw_ascii),
		.capslock(capslock),
		.shift(shift),
		.asciicode(ascii_code)
	);
	assign LEDR[9:8] = {capslock, shift};

	
	// VGA Screen
	wire [23:0] vga_data;
	wire [9:0] h_addr, v_addr;
	assign VGA_CLK = clk;
	assign VGA_SYNC_N = 0;
	vga_ctrl myvga(
		.pclk(clk),
		.reset(rstvga),
		.vga_data(vga_data),
		.h_addr(h_addr),
		.v_addr(v_addr),
		.hsync(VGA_HS),
		.vsync(VGA_VS),
		.valid(VGA_BLANK_N),
		.vga_r(VGA_R),
		.vga_g(VGA_G),
		.vga_b(VGA_B)
	);
	loadscreen myloader(
		.pclk(clk),
		.rst(rstvga),
		.ascii_code(smemoutdata),
		.h_addr(h_addr),
		.v_addr(v_addr),
		.rdclk(smemrdclk),
		.rdaddr(smemrdaddr),
		.vga_data(vga_data)
	);
	

	// BCD SEG
	bcd7seg myseg0(bcdreg[3:0], HEX0);
	bcd7seg myseg1(bcdreg[7:4], HEX1);
	bcd7seg myseg2(bcdreg[11:8], HEX2);
	bcd7seg myseg3(bcdreg[15:12], HEX3);
	bcd7seg myseg4(bcdreg[19:16], HEX4);
	bcd7seg myseg5(bcdreg[23:20], HEX5);
	
	
	// LED Light
	assign LEDR[7:0] = ledreg[7:0];
	
	// CLOCK
	wire clk1s, rco;
	wire[3:0] h_t, h_o, m_t, m_o, s_t, s_o;
	clk_1s myclk_1s(CLOCK_50, clk1s);
	clock myclock(
		.en(1'b1),
		.clk(clk1s), 
		.rst(rsttime),
		.cin(24'd0),
		.hour_t(h_t),
		.hour_o(h_o),
		.min_t(m_t),
		.min_o(m_o),
		.sec_t(s_t),
		.sec_o(s_o),
		.rco(rco)
	);
	assign timereg = {h_t, h_o, m_t, m_o, s_t, s_o};
	

endmodule
